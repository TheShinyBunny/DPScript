package com.shinysponge.dpscript.project;

import com.shinybunny.utils.StringUtils;
import com.shinybunny.utils.fs.Files;
import com.shinysponge.dpscript.entities.Entities;
import com.shinysponge.dpscript.oop.AbstractClass;
import com.shinysponge.dpscript.oop.DPClass;
import com.shinysponge.dpscript.pawser.CompilationError;
import com.shinysponge.dpscript.pawser.GlobalLaterCheck;
import com.shinysponge.dpscript.pawser.Parser;
import com.shinysponge.dpscript.pawser.Variable;
import com.shinysponge.dpscript.tokenizew.CodePos;
import com.shinysponge.dpscript.tokenizew.Token;

import java.io.File;
import java.util.*;
import java.util.stream.Collectors;

public class CompilationContext {

    private List<Datapack> imports;
    private Datapack project;
    private File file;

    public Map<String, Integer> consts = new HashMap<>();
    public List<String> bossbars = new ArrayList<>();
    public List<String> objectives = new ArrayList<>();
    public List<String> globals = new ArrayList<>();
    public List<String> triggers = new ArrayList<>();
    private Map<String,Integer> autoGenerated = new HashMap<>();
    private List<CompilationError> errors = new ArrayList<>();
    private List<MCFunction> loads = new ArrayList<>();
    private List<MCFunction> ticks = new ArrayList<>();
    private MCFunction currentLoad;
    private MCFunction mainLoad;
    private MCFunction currentTick;
    private MCFunction mainTick;
    public List<GlobalLaterCheck> checks = new ArrayList<>();
    public Map<Token, String[]> suggestions = new HashMap<>();
    public Map<String, AbstractClass> classes = new HashMap<>();
    public Stack<Map<String,Variable>> variables = new Stack<>();
    private String path = "";
    private Namespace namespace;
    private long startTime;

    public CompilationContext(Datapack datapack) {
        this.project = datapack;
        this.variables.push(new HashMap<>());
        this.classes.put("int",DPClass.INT);
        this.classes.put("string",DPClass.STRING);
        this.classes.put("boolean",DPClass.BOOLEAN);
        this.classes.put("double",DPClass.DOUBLE);
        for (Entities e : Entities.values()) {
            this.classes.put(e.getTypeClass().getName(),e.getTypeClass());
        }
    }

    public CompilationResults compile() {
        startTime = System.currentTimeMillis();
        Parser.init(this);
        namespace = project.getDefaultNamespace();
        for (File f : project.getDir().listFiles()) {
            if (!f.getName().equalsIgnoreCase("ignore")) {
                compileFile(f);
            }
        }
        runChecks();
        setNamespace(null);
        project.getMinecraftNamespace().addTag("function","tick",ticks);
        project.getMinecraftNamespace().addTag("function","load",loads);

        logResults();
        return getResults();
    }

    private void compileFile(File f) {
        if (f.isDirectory()) {
            setNamespace(new Namespace(f));
            project.getNamespaces().add(namespace);
            for (File subFile : f.listFiles()) {
                compileSingleFile(subFile);
            }
            namespace = project.getDefaultNamespace();
        } else {
            compileSingleFile(f);
        }
    }

    private void setNamespace(Namespace namespace) {
        mainLoad = null;
        mainTick = null;
        currentLoad = null;
        currentTick = null;
        this.namespace = namespace;
    }

    private void compileSingleFile(File file) {
        System.out.println("compiling single file " + file);
        if (file.isDirectory()) {
            String prev = path;
            path += "/" + file.getName();
            for (File f : file.listFiles()) {
                compileSingleFile(f);
            }
            path = prev;
        } else {
            compileDPScript(file);
        }
    }

    private void compileDPScript(File file) {
        System.out.println("compiling potential script " + file);
        if (Files.extension(file).equals("dps")) {
            System.out.println("it has extension DPS, so yay!");
            this.file = file;
            variables.clear();
            variables.push(new HashMap<>());
            Parser.parse(file);
            this.file = null;
        }
    }

    public MCFunction addFunction(String name) {
        MCFunction f = new MCFunction(namespace, path + name);
        namespace.addFunction(f);
        return f;
    }

    public void suggest(Token token, String... suggestions) {
        this.suggestions.put(token,suggestions);
    }

    public void addTick(String command) {
        if (mainTick == null) {
            mainTick = addFunction("loop");
        }
        mainTick.add(command);
    }

    public void addLoad(String command) {
        if (mainLoad == null) {
            mainLoad = addFunction("init");
        }
        mainLoad.add(command);
    }

    public MCFunction getFunction(String name) {
        return namespace.getFunction(name.substring(name.indexOf(":")+1));
    }

    public void addError(CompilationError err) {
        System.out.println("added compilation error: ");
        err.printStackTrace(System.out);
        errors.add(err);
    }

    public boolean hasConstant(String name) {
        return consts.containsKey(name);
    }

    public boolean hasGlobal(String name) {
        return globals.contains(name);
    }

    public String generateFunctionName(String type) {
        int i = autoGenerated.getOrDefault(type,0)+1;
        autoGenerated.put(type,i);
        return type + "_" + i;
    }

    public void addFunction(String name, List<String> commands) {
        System.out.println("adding function " + name);
        MCFunction f = addFunction(name);
        commands.forEach(f::add);
    }

    /**
     * Returns a /function [namespace]:[name] command.
     * if that function doesn't exist, will wait for the end of compilation and will throw a compilation error if it doesn't exist.
     * @param pos The token position of where the function was called
     * @param name The functions name
     */
    public String callFunction(CodePos pos, String name) {
        if (getFunction(name) == null) {
            checks.add(new GlobalLaterCheck(name,"function",pos,ctx->ctx.getFunction(name) != null));
        }
        return "function " + namespace.getName() + ":" + StringUtils.toLowerCaseUnderscore(name);
    }

    public void enterBlock() {
        variables.push(new HashMap<>());
    }

    public void exitBlock() {
        variables.pop();
    }

    public void putVariable(String name, Variable value) {
        variables.peek().put(name,value);
    }

    public Variable getVariable(String name) {
        return variables.peek().get(name);
    }

    public void runChecks() {
        checks.forEach(c->c.check(this));
    }

    public void logResults() {
        if (!errors.isEmpty()) {
            System.out.println(">>>>>>>>>>> COMPILATION FAILED <<<<<<<<<<<<<");
            for (CompilationError e : errors.stream().sorted(Comparator.comparing(CompilationError::getPos)).collect(Collectors.toList())) {
                System.out.println("line " + e.getPos().getLine() + ": " + e.getMessage());
                System.out.println("------------------------");
            }
        } else {
            System.out.println(">>>>>>>>>>>> COMPILATION SUCCEED <<<<<<<<<<<<");
            System.out.println("Generated " + project.getNamespaces().stream().map(Namespace::getFunctions).map(Collection::size).reduce(Integer::sum).orElse(0) + " functions");
            System.out.println("Elapsed time: " + (System.currentTimeMillis() - startTime) + "ms");
        }
    }

    public void ensureConstants() {
        ensureObjective("Consts");
    }

    public void ensureGlobal() {
        ensureObjective("Global");
    }

    public String getNamespace() {
        return project.getName();
    }

    public CompilationResults getResults() {
        return new CompilationResults(project,errors,suggestions);
    }

    public boolean hasClass(String name) {
        return classes.containsKey(name);
    }

    public void ensureObjective(String name) {
        if (!objectives.contains(name)) {
            objectives.add(name);
            addLoad("scoreboard objectives add " + name + " dummy");
        }
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getPath() {
        return path;
    }

    public void addTickFunction(String name, List<String> cmds) {
        if (mainTick == null) {
            MCFunction f = addFunction(name);
            f.addAll(cmds);
            ticks.add(f);
            mainTick = f;
            currentTick = f;
        } else if (currentTick == null){
            mainTick.addAll(cmds);
            mainTick.setName(name);
        } else {
            MCFunction f = addFunction(name);
            f.addAll(cmds);
            ticks.add(f);
        }
    }

    public void addLoadFunction(String name, List<String> cmds) {
        if (mainLoad == null) {
            MCFunction f = addFunction(name);
            f.addAll(cmds);
            loads.add(f);
            mainLoad = f;
            currentLoad = f;
        } else if (currentLoad == null){
            mainLoad.addAll(cmds);
            mainLoad.setName(name);
        } else {
            MCFunction f = addFunction(name);
            f.addAll(cmds);
            loads.add(f);
        }
    }

    public File getFile() {
        return file;
    }
}
